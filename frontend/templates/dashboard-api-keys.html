{% extends "base_dashboard.html" %}

{% block title %}API Keys - NotionFlow{% endblock %}

{% block extra_css %}
<link rel="stylesheet"
    href="{{ url_for('static', filename='css/api-keys-redesign.css') }}?v={{ range(100000, 999999) | random }}">
<link rel="stylesheet"
    href="{{ url_for('static', filename='css/unified-sync-modal.css') }}?v={{ range(100000, 999999) | random }}">
{% endblock %}

{% block content %}
<!-- API 키 관리 메인 컨테이너 -->
<div class="api-container">

    <!-- 헤더 섹션 -->
    <div class="api-header-container">
        <div class="api-header">
            <div class="api-title-section">
                <h1 class="api-main-title">🔑 API 키 관리</h1>
                <p class="api-subtitle">플랫폼과 안전하게 연결하고 캘린더를 동기화하세요</p>
            </div>
        </div>
    </div>

    <!-- 캘린더 생성 안내 섹션 -->
    <div class="calendar-setup-guide" id="calendar-setup-guide">
        <div class="guide-card">
            <div class="guide-content">
                <h3 class="guide-title">🎯 시작하기 전에</h3>
                <p class="guide-description">
                    플랫폼을 연결하기 전에 먼저 <strong>캘린더를 생성</strong>해야 합니다.<br>
                    캘린더가 있어야 각 플랫폼의 이벤트를 동기화할 수 있어요!
                </p>
                <div class="guide-steps">
                    <div class="step-item">
                        <span class="step-number">1</span>
                        <span class="step-text">캘린더 생성하기</span>
                    </div>
                    <div class="step-item">
                        <span class="step-number">2</span>
                        <span class="step-text">플랫폼 연결하기</span>
                    </div>
                    <div class="step-item">
                        <span class="step-number">3</span>
                        <span class="step-text">자동 동기화 시작</span>
                    </div>
                </div>
                <div class="guide-actions">
                    <a href="/calendar" class="guide-btn primary">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path
                                d="M8 2v4M16 2v4M3 10h18M5 4h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z" />
                        </svg>
                        캘린더 생성하기
                    </a>
                    <button class="guide-btn secondary" onclick="hideCalendarGuide()">
                        나중에 하기
                    </button>
                </div>
            </div>
            <button class="guide-close" onclick="hideCalendarGuide()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 6l-12 12M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

    <!-- 플랫폼 연결 섹션 -->
    <div class="platforms-section">

        <!-- Notion 연결 카드 -->
        <div class="platform-card" data-platform="notion">
            <div class="platform-header">
                <div class="platform-info">
                    <div class="platform-icon notion">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M4.459 4.208c.746.606 1.026.56 2.428.466l13.215-.793c.28 0 .047-.28-.046-.326L17.86 1.968c-.42-.326-.981-.7-2.055-.607L3.01 2.295c-.466.046-.56.28-.374.466zm.793 3.08v13.904c0 .747.373 1.027 1.214.98l14.523-.84c.841-.046 1.121-.56 1.121-1.167V6.354c0-.606-.233-.933-.747-.887l-15.177.887c-.56.047-.934.373-.934 1.027zm13.748.327c.093.42 0 .84-.42.888l-.7.14v10.264c-.608.327-1.168.514-1.635.514-.748 0-.935-.234-1.495-.933l-4.577-7.186v6.952L12.21 19s0 .84-1.168.84l-3.222.186c-.093-.186 0-.653.327-.746l.84-.233V9.854L7.822 9.76c-.094-.42.14-1.026.793-1.073l3.456-.233 4.764 7.279v-6.44l-1.215-.139c-.093-.514.28-.887.747-.933z" />
                        </svg>
                    </div>
                    <div class="platform-details">
                        <h3 class="platform-name">Notion</h3>
                        <div class="platform-status disconnected">
                            <span class="status-dot"></span>
                            연결되지 않음
                        </div>
                    </div>
                </div>
                <div class="platform-actions">
                    <button class="one-click-btn-small" onclick="oneClickConnect('notion')" data-platform="notion">
                        <span class="btn-text">원클릭</span>
                        <div class="btn-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                        </div>
                    </button>
                    <button class="platform-sync-btn" onclick="openCalendarSyncModal('notion')" data-platform="notion"
                        style="display: none;">
                        <span class="sync-text">캘린더 연동</span>
                        <div class="sync-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                    <button class="platform-connect-btn" onclick="connectPlatform('notion')" data-platform="notion">
                        <span class="connect-text">연결하기</span>
                        <div class="connect-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                    <button class="platform-expand-btn" onclick="togglePlatformDetails('notion')">
                        <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M6 9l6 6 6-6" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- 연결 상세 폼 -->
            <div class="platform-details-form" id="notion-details" style="display: none;">
                <div class="form-group">
                    <label for="notion-token">Internal Integration Token</label>
                    <input type="password" id="notion-token" name="notion-token" placeholder="secret_으로 시작하는 토큰을 입력하세요">
                    <small class="form-help">
                        <a href="https://www.notion.so/my-integrations" target="_blank" class="help-link">
                            📖 토큰 발급받기
                        </a>
                        | 페이지 접근 권한 필요
                    </small>
                </div>
                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="togglePlatformDetails('notion')">취소</button>
                    <button class="btn btn-primary" onclick="connectPlatform('notion')">
                        <span class="loading-spinner" style="display: none;"></span>
                        연결하기
                    </button>
                </div>
            </div>
        </div>

        <!-- Google Calendar 연결 카드 -->
        <div class="platform-card" data-platform="google">
            <div class="platform-header">
                <div class="platform-info">
                    <div class="platform-icon google">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z" />
                        </svg>
                    </div>
                    <div class="platform-details">
                        <h3 class="platform-name">Google Calendar</h3>
                        <div class="platform-status disconnected">
                            <span class="status-dot"></span>
                            연결되지 않음
                        </div>
                    </div>
                </div>
                <div class="platform-actions">
                    <button class="one-click-btn-small" onclick="oneClickConnect('google')" data-platform="google">
                        <span class="btn-text">원클릭</span>
                        <div class="btn-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                        </div>
                    </button>
                    <button class="platform-sync-btn" onclick="window.googleManager ? window.googleManager.connect() : console.warn('GoogleManager not available')" data-platform="google"
                        style="display: none;">
                        <span class="sync-text">캘린더 동기화</span>
                        <div class="sync-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                </div>
            </div>
        </div>

        <!-- Apple Calendar 연결 카드 -->
        <div class="platform-card" data-platform="apple">
            <div class="platform-header">
                <div class="platform-info">
                    <div class="platform-icon apple">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M19.5 4h-1.44a2.04 2.04 0 0 0-1.98 1.22l-1.58 4.49c-.25.7-.91 1.16-1.65 1.16-.73 0-1.39-.46-1.64-1.16l-1.58-4.49A2.04 2.04 0 0 0 7.62 4H6.5C5.67 4 5 4.67 5 5.5S5.67 7 6.5 7h1.12c.14 0 .27.09.32.22l1.58 4.49c.5 1.4 1.82 2.29 3.31 2.29s2.81-.89 3.31-2.29L17.72 7.22c.05-.13.18-.22.32-.22H19.5c.83 0 1.5-.67 1.5-1.5S20.33 4 19.5 4z" />
                        </svg>
                    </div>
                    <div class="platform-details">
                        <h3 class="platform-name">Apple Calendar</h3>
                        <div class="platform-status disconnected">
                            <span class="status-dot"></span>
                            연결되지 않음
                        </div>
                    </div>
                </div>
                <div class="platform-actions">
                    <button class="platform-sync-btn" onclick="openCalendarSyncModal('apple')" data-platform="apple"
                        style="display: none;">
                        <span class="sync-text">캘린더 연동</span>
                        <div class="sync-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                    <button class="platform-connect-btn" onclick="connectPlatform('apple')" data-platform="apple">
                        <span class="connect-text">연결하기</span>
                        <div class="connect-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                    <button class="platform-expand-btn" onclick="togglePlatformDetails('apple')">
                        <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M6 9l6 6 6-6" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- 연결 상세 폼 -->
            <div class="platform-details-form" id="apple-details" style="display: none;">
                <div class="form-group">
                    <label for="apple-username">Apple ID</label>
                    <input type="email" id="apple-username" name="apple-username"
                        placeholder="your-apple-id@icloud.com">
                </div>
                <div class="form-group">
                    <label for="apple-password">앱 전용 암호</label>
                    <input type="password" id="apple-password" name="apple-password" placeholder="앱 전용 암호">
                    <small class="form-help">
                        <a href="https://support.apple.com/en-us/HT204397" target="_blank" class="help-link">
                            📖 앱 전용 암호 만들기
                        </a>
                        | 2단계 인증 필요
                    </small>
                </div>
                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="togglePlatformDetails('apple')">취소</button>
                    <button class="btn btn-primary" onclick="connectPlatform('apple')">
                        <span class="loading-spinner" style="display: none;"></span>
                        연결하기
                    </button>
                </div>
            </div>
        </div>

        <!-- Outlook 연결 카드 -->
        <div class="platform-card" data-platform="outlook">
            <div class="platform-header">
                <div class="platform-info">
                    <div class="platform-icon outlook">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M7.88 12.04q0 .45-.11.87-.1.41-.33.74-.22.33-.58.52-.37.2-.87.2-.51 0-.87-.2-.37-.19-.59-.52-.21-.33-.32-.74-.1-.42-.1-.87 0-.44.1-.86.11-.41.32-.73.22-.33.59-.52.36-.2.87-.2.5 0 .87.2.36.19.58.52.23.32.33.73.11.42.11.86zM21.5 4v16q0 .41-.3.7-.29.3-.7.3H3.5q-.41 0-.7-.3-.3-.29-.3-.7V4q0-.41.3-.7Q2.79 3 3.2 3h17.6q.41 0 .7.29.3.29.3.71zM8.5 13.5H7.25v.75H8.5v-.75zm0-3H7.25V11H8.5v-.5zM12 7.98H9v8h3V7.98zm6.5 2.53-2.25 2.02 2.25 2.05V10.51z" />
                        </svg>
                    </div>
                    <div class="platform-details">
                        <h3 class="platform-name">Outlook</h3>
                        <div class="platform-status disconnected">
                            <span class="status-dot"></span>
                            연결되지 않음
                        </div>
                    </div>
                </div>
                <div class="platform-actions">
                    <button class="platform-sync-btn" onclick="openCalendarSyncModal('outlook')" data-platform="outlook"
                        style="display: none;">
                        <span class="sync-text">캘린더 연동</span>
                        <div class="sync-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                    <button class="one-click-btn-small" onclick="oneClickConnect('outlook')" data-platform="outlook">
                        <span class="btn-text">원클릭</span>
                        <div class="btn-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                        </div>
                    </button>
                    <button class="platform-connect-btn" onclick="connectPlatform('outlook')" data-platform="outlook">
                        <span class="connect-text">연결하기</span>
                        <div class="connect-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                    <button class="platform-expand-btn" onclick="togglePlatformDetails('outlook')">
                        <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M6 9l6 6 6-6" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- 연결 상세 폼 -->
            <div class="platform-details-form" id="outlook-details" style="display: none;">
                <div class="form-group">
                    <label for="outlook-email">Microsoft 계정</label>
                    <input type="email" id="outlook-email" name="outlook-email" placeholder="your-email@outlook.com">
                </div>
                <div class="form-group">
                    <label for="outlook-client-id">클라이언트 ID</label>
                    <input type="text" id="outlook-client-id" name="outlook-client-id"
                        placeholder="Azure 앱 등록에서 발급받은 클라이언트 ID">
                    <small class="form-help">
                        <a href="https://portal.azure.com/" target="_blank" class="help-link">
                            📖 Azure Portal에서 앱 등록하기
                        </a>
                        | Graph API 권한 필요
                    </small>
                </div>
                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="togglePlatformDetails('outlook')">취소</button>
                    <button class="btn btn-primary" onclick="connectPlatform('outlook')">
                        <span class="loading-spinner" style="display: none;"></span>
                        연결하기
                    </button>
                </div>
            </div>
        </div>

        <!-- Slack 연결 카드 -->
        <div class="platform-card" data-platform="slack">
            <div class="platform-header">
                <div class="platform-info">
                    <div class="platform-icon slack">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M5.042 15.165a2.528 2.528 0 0 1-2.52 2.523A2.528 2.528 0 0 1 0 15.165a2.527 2.527 0 0 1 2.522-2.52h2.52v2.52zM6.313 15.165a2.527 2.527 0 0 1 2.521-2.52 2.527 2.527 0 0 1 2.521 2.52v6.313A2.528 2.528 0 0 1 8.834 24a2.528 2.528 0 0 1-2.521-2.522v-6.313zM8.834 5.042a2.528 2.528 0 0 1-2.521-2.52A2.528 2.528 0 0 1 8.834 0a2.528 2.528 0 0 1 2.521 2.522v2.52H8.834zM8.834 6.313a2.528 2.528 0 0 1 2.521 2.521 2.528 2.528 0 0 1-2.521 2.521H2.522A2.528 2.528 0 0 1 0 8.834a2.528 2.528 0 0 1 2.522-2.521h6.312zM18.956 8.834a2.528 2.528 0 0 1 2.521-2.521A2.528 2.528 0 0 1 24 8.834a2.528 2.528 0 0 1-2.523 2.521h-2.521V8.834zM17.688 8.834a2.528 2.528 0 0 1-2.523 2.521 2.527 2.527 0 0 1-2.52-2.521V2.522A2.527 2.527 0 0 1 15.165 0a2.528 2.528 0 0 1 2.523 2.522v6.312zM15.165 18.956a2.528 2.528 0 0 1 2.523 2.521A2.528 2.528 0 0 1 15.165 24a2.527 2.527 0 0 1-2.52-2.523v-2.521h2.52zM15.165 17.688a2.527 2.527 0 0 1-2.52-2.523 2.526 2.526 0 0 1 2.52-2.52h6.313A2.527 2.527 0 0 1 24 15.165a2.528 2.528 0 0 1-2.522 2.523h-6.313z" />
                        </svg>
                    </div>
                    <div class="platform-details">
                        <h3 class="platform-name">Slack</h3>
                        <div class="platform-status disconnected">
                            <span class="status-dot"></span>
                            연결되지 않음
                        </div>
                    </div>
                </div>
                <div class="platform-actions">
                    <button class="platform-sync-btn" onclick="openCalendarSyncModal('slack')" data-platform="slack"
                        style="display: none;">
                        <span class="sync-text">캘린더 연동</span>
                        <div class="sync-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                    <button class="one-click-btn-small" onclick="oneClickConnect('slack')" data-platform="slack">
                        <span class="btn-text">원클릭</span>
                        <div class="btn-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                        </div>
                    </button>
                    <button class="platform-connect-btn" onclick="connectPlatform('slack')" data-platform="slack">
                        <span class="connect-text">연결하기</span>
                        <div class="connect-loader" style="display: none;">
                            <div class="loader-dot"></div>
                        </div>
                    </button>
                    <button class="platform-expand-btn" onclick="togglePlatformDetails('slack')">
                        <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M6 9l6 6 6-6" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- 연결 상세 폼 -->
            <div class="platform-details-form" id="slack-details" style="display: none;">
                <div class="form-group">
                    <label for="slack-webhook">Webhook URL</label>
                    <input type="url" id="slack-webhook" name="slack-webhook"
                        placeholder="https://hooks.slack.com/services/...">
                    <small class="form-help">
                        <a href="https://api.slack.com/messaging/webhooks" target="_blank" class="help-link">
                            📖 Slack Webhook 만들기
                        </a>
                        | 워크스페이스 관리자 권한 필요
                    </small>
                </div>
                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="togglePlatformDetails('slack')">취소</button>
                    <button class="btn btn-primary" onclick="connectPlatform('slack')">
                        <span class="loading-spinner" style="display: none;"></span>
                        연결하기
                    </button>
                </div>
            </div>
        </div>

    </div>
</div>

<!-- 캘린더 선택 모달 -->
<div class="calendar-selection-modal" id="calendar-selection-modal" style="display: none;">
    <div class="modal-overlay" onclick="closeCalendarSelectionModal()"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">캘린더 변경</h3>
            <button class="modal-close-btn" onclick="closeCalendarSelectionModal()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 6l-12 12M6 6l12 12" />
                </svg>
            </button>
        </div>
        <div class="modal-body">
            <p class="modal-description">
                <span id="platform-name-display"></span> 연결을 위해 동기화할 캘린더를 선택하세요.
            </p>
            <div class="calendar-list" id="calendar-list">
                <div class="loading-state">
                    <div class="loading-spinner"></div>
                    <p>캘린더 목록을 불러오는 중...</p>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn-secondary" onclick="closeCalendarSelectionModal()">취소</button>
            <button class="btn-primary" id="confirm-calendar-selection" onclick="confirmCalendarSelection()" disabled>
                선택한 캘린더로 연결
            </button>
        </div>
    </div>
</div>

<!-- Google Calendar Manager -->
<script src="{{ url_for('static', filename='js/google-calendar-manager.js') }}?v={{ range(100000, 999999) | random }}"></script>

<!-- Notion Calendar Manager -->
<script src="{{ url_for('static', filename='js/notion-calendar-manager.js') }}?v={{ range(100000, 999999) | random }}"></script>

<!-- 초기 데이터 설정 스크립트 -->
<script>
    // 서버에서 렌더링된 데이터 (캘린더가 있는지 확인)
    const hasCalendar = {{ (stats.connected_count if stats and stats.connected_count else 0) | tojson }} > 0;

    // 페이지 로드 시 즉시 가이드 처리
    document.addEventListener('DOMContentLoaded', function () {
        const guide = document.getElementById('calendar-setup-guide');
        if (guide) {
            const isHidden = localStorage.getItem('calendar_guide_hidden') === 'true';

            // 캘린더가 있거나 사용자가 이미 숨긴 경우
            if (hasCalendar || isHidden) {
                guide.style.display = 'none';
            } else {
                guide.style.display = 'block';
            }
        }
    });
</script>

<style>
    /* 캘린더 선택 모달 스타일 */
    .calendar-selection-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 999999;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .modal-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
    }

    .modal-content {
        position: relative;
        background: #ffffff;
        border-radius: 16px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        overflow: hidden;
    }

    .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 24px 32px;
        border-bottom: 1px solid #f0f0f0;
    }

    .modal-title {
        font-size: 20px;
        font-weight: 600;
        color: #000000;
        margin: 0;
    }

    .modal-close-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 4px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #6b7280;
        transition: all 0.2s ease;
    }

    .modal-close-btn:hover {
        background: #f9fafb;
        color: #000000;
    }

    .modal-body {
        padding: 32px;
        max-height: 400px;
        overflow-y: auto;
    }

    .modal-description {
        font-size: 16px;
        color: #6b7280;
        margin-bottom: 24px;
        line-height: 1.5;
    }

    .calendar-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .calendar-item {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 16px;
        border: 2px solid #e5e7eb;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        background: #ffffff;
    }

    .calendar-item:hover {
        border-color: #3b82f6;
        background: #f8faff;
    }

    .calendar-item.selected {
        border-color: #3b82f6;
        background: #eff6ff;
    }

    .calendar-radio {
        width: 20px;
        height: 20px;
        border: 2px solid #d1d5db;
        border-radius: 50%;
        position: relative;
        flex-shrink: 0;
    }

    .calendar-item.selected .calendar-radio {
        border-color: #3b82f6;
    }

    .calendar-item.selected .calendar-radio::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 10px;
        height: 10px;
        background: #3b82f6;
        border-radius: 50%;
    }

    .calendar-info {
        flex: 1;
    }

    .calendar-name {
        font-size: 16px;
        font-weight: 500;
        color: #000000;
        margin-bottom: 4px;
    }

    .calendar-description {
        font-size: 14px;
        color: #6b7280;
    }

    .calendar-type {
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        text-transform: uppercase;
    }

    .calendar-type.primary {
        background: #dbeafe;
        color: #1d4ed8;
    }

    .calendar-type.shared {
        background: #d1fae5;
        color: #047857;
    }

    .calendar-type.personal {
        background: #fef3c7;
        color: #d97706;
    }

    .loading-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        padding: 40px 20px;
        color: #6b7280;
    }

    .loading-spinner {
        width: 32px;
        height: 32px;
        border: 3px solid #e5e7eb;
        border-top: 3px solid #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    .modal-footer {
        display: flex;
        gap: 12px;
        padding: 24px 32px;
        border-top: 1px solid #f0f0f0;
        justify-content: flex-end;
    }

    .btn-secondary,
    .btn-primary {
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        border: none;
        min-width: 120px;
    }

    .btn-secondary {
        background: #ffffff;
        color: #6b7280;
        border: 1px solid #e5e7eb;
    }

    .btn-secondary:hover {
        background: #f9fafb;
        color: #000000;
    }

    .btn-primary {
        background: #3b82f6;
        color: #ffffff;
    }

    .btn-primary:hover:not(:disabled) {
        background: #2563eb;
    }

    .btn-primary:disabled {
        background: #9ca3af;
        cursor: not-allowed;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    /* 새로운 버튼 디자인 스타일 */
    .one-click-btn-small {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 10px 18px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 12px;
        position: relative;
        min-width: 100px;
        justify-content: center;
        background: #3b82f6;
        color: white;
        border: none;
        overflow: hidden;
        letter-spacing: 0.3px;
    }

    .one-click-btn-small::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 0;
    }

    .one-click-btn-small:hover::before {
        opacity: 1;
    }

    .one-click-btn-small:hover {
        transform: translateY(-2px) scale(1.02);
        box-shadow: 0 10px 25px rgba(59, 130, 246, 0.4);
    }

    .one-click-btn-small .btn-icon {
        font-size: 16px;
        position: relative;
        z-index: 1;
    }

    .one-click-btn-small .btn-text {
        position: relative;
        z-index: 1;
    }

    .platform-connect-btn,
    .platform-sync-btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 20px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 12px;
        position: relative;
        min-width: 110px;
        justify-content: center;
        background: #ffffff;
        color: #1a1a1a;
        border: 2px solid #e5e7eb;
        overflow: hidden;
    }

    .platform-sync-btn {
        background: #3b82f6;
        color: white;
        border: none;
        justify-content: center;
        text-align: center;
    }

    .platform-sync-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(59, 130, 246, 0.3);
    }

    .platform-connect-btn::before,
    .platform-sync-btn::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: #3b82f6;
        transform: translate(-50%, -50%);
        transition: width 0.4s ease, height 0.4s ease;
        z-index: 0;
    }

    .platform-connect-btn:hover::before {
        width: 300px;
        height: 300px;
    }

    .platform-connect-btn:hover {
        color: white;
        border-color: #3b82f6;
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
    }

    .platform-connect-btn .connect-text {
        position: relative;
        z-index: 1;
        transition: color 0.3s ease;
    }

    .platform-connect-btn:hover .connect-text {
        color: white;
    }

    .platform-disconnect-btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 20px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 12px;
        position: relative;
        min-width: 110px;
        justify-content: center;
        background: linear-gradient(135deg, #ff6b6b 0%, #ff8787 100%);
        color: white;
        border: none;
    }

    .platform-disconnect-btn:hover {
        background: linear-gradient(135deg, #ff5252 0%, #ff6b6b 100%);
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(255, 107, 107, 0.3);
    }

    /* Google Calendar 연결해제 버튼 (platform-disconnect-btn과 동일한 스타일) */
    .google-disconnect-btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 20px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 12px;
        position: relative;
        min-width: 110px;
        justify-content: center;
        background: linear-gradient(135deg, #ff6b6b 0%, #ff8787 100%);
        color: white;
        border: none;
    }

    .google-disconnect-btn:hover {
        background: linear-gradient(135deg, #ff5252 0%, #ff6b6b 100%);
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(255, 107, 107, 0.3);
    }

    /* One-click 연결해제 버튼 (Google Calendar용) */
    .one-click-disconnect-btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 20px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 12px;
        position: relative;
        min-width: 110px;
        justify-content: center;
        background: linear-gradient(135deg, #ff6b6b 0%, #ff8787 100%) !important;
        color: white !important;
        border: none !important;
    }

    .one-click-disconnect-btn:hover {
        background: linear-gradient(135deg, #ff5252 0%, #ff6b6b 100%) !important;
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(255, 107, 107, 0.3);
    }

    /* 연결하기 버튼 로딩 상태 */
    .platform-connect-btn.loading {
        pointer-events: none;
        opacity: 0.8;
    }

    .connect-loader {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: inherit;
        border-radius: inherit;
    }

    .loader-dot {
        width: 8px;
        height: 8px;
        background: #3b82f6;
        border-radius: 50%;
        animation: bounce 1.4s infinite ease-in-out both;
    }

    .loader-dot::before,
    .loader-dot::after {
        content: '';
        position: absolute;
        width: 8px;
        height: 8px;
        background: #3b82f6;
        border-radius: 50%;
        animation: bounce 1.4s infinite ease-in-out both;
    }

    .loader-dot::before {
        left: -16px;
        animation-delay: -0.32s;
    }

    .loader-dot::after {
        left: 16px;
        animation-delay: -0.16s;
    }

    @keyframes bounce {

        0%,
        80%,
        100% {
            transform: scale(0);
        }

        40% {
            transform: scale(1);
        }
    }


    /* 캘린더가 없을 때 플랫폼 카드 비활성화 스타일 */
    .platform-card.disabled {
        opacity: 0.5;
        pointer-events: none;
        position: relative;
    }

    .platform-card.disabled::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        cursor: not-allowed;
    }

    .platform-card.disabled .platform-actions button {
        cursor: not-allowed;
        opacity: 0.6;
    }

    .no-calendar-notice {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 12px 20px;
        border-radius: 8px;
        border: 1px solid #fbbf24;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        z-index: 10;
        display: none;
    }

    .platform-card.disabled:hover .no-calendar-notice {
        display: block;
    }

    .no-calendar-notice-text {
        color: #92400e;
        font-size: 14px;
        font-weight: 500;
    }

    /* OAuth 연동 완료 상태 스타일 */
    .platform-status.oauth-connected,
    .platform-status.partial {
        color: #f59e0b;
        background: #fef3c7;
        border: 1px solid #fbbf24;
    }

    .platform-status.oauth-connected .status-dot,
    .platform-status.partial .status-dot {
        background: #f59e0b;
        animation: pulse-orange 2s infinite;
    }

    @keyframes pulse-orange {

        0%,
        100% {
            opacity: 1;
        }

        50% {
            opacity: 0.5;
        }
    }

    /* 캘린더 연동 해제 X 버튼 스타일 */
    .sync-disconnect-btn {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        border: none;
        background: #dc2626;
        color: white;
        border-radius: 50%;
        font-size: 12px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        z-index: 2;
    }

    .sync-disconnect-btn:hover {
        background: #b91c1c;
        transform: translateY(-50%) scale(1.1);
    }

    .sync-disconnect-btn:disabled {
        background: #9ca3af;
        cursor: not-allowed;
    }

    @keyframes spin {
        from {
            transform: translateY(-50%) rotate(0deg);
        }

        to {
            transform: translateY(-50%) rotate(360deg);
        }
    }

    /* 연동된 버튼의 패딩 조정 */
    .platform-sync-btn.synced {
        padding-right: 36px;
    }

    /* Removed import button styles - auto-import on connection now */
</style>
{% endblock %}

{% block extra_js %}
<!-- Core notification system이 먼저 로드되어야 함 -->
<script
    src="{{ url_for('static', filename='js/notification-utils.js') }}?v={{ range(100000, 999999) | random }}"></script>
<script
    src="{{ url_for('static', filename='js/apple-setup-wizard.js') }}?v={{ range(100000, 999999) | random }}"></script>
<script src="{{ url_for('static', filename='js/platform-health.js') }}?v={{ range(100000, 999999) | random }}"></script>
<!-- Old platform-managers.js disabled - using new GoogleCalendarManager instead -->
<!-- <script src="{{ url_for('static', filename='js/platform-managers.js') }}?v={{ range(100000, 999999) | random }}"></script> -->
<script src="{{ url_for('static', filename='js/platform-card.js') }}?v={{ range(100000, 999999) | random }}"></script>
<script
    src="{{ url_for('static', filename='js/unified-sync-modal.js') }}?v={{ range(100000, 999999) | random }}"></script>
<script>
    // 🚀 CALENDAR GRID REFRESH TRIGGER FUNCTION
    function triggerCalendarGridRefresh(calendarId, syncedCount = 0) {
        console.log(`🚀 [TRIGGER] Starting calendar grid refresh for calendar ${calendarId} with ${syncedCount} events`);

        try {
            // Method 1: localStorage event trigger for same-origin communication
            const refreshData = {
                timestamp: Date.now(),
                calendar_id: calendarId,
                synced_count: syncedCount,
                action: 'refresh_calendar_grid'
            };

            localStorage.setItem('calendar_grid_refresh_trigger', JSON.stringify(refreshData));
            console.log('✅ [TRIGGER] localStorage refresh trigger set');

            // Remove the trigger after a short delay to avoid multiple triggers
            setTimeout(() => {
                localStorage.removeItem('calendar_grid_refresh_trigger');
            }, 1000);

            // Method 2: Direct window communication if available
            if (window.opener && !window.opener.closed) {
                window.opener.postMessage({
                    type: 'CALENDAR_GRID_REFRESH',
                    calendar_id: calendarId,
                    synced_count: syncedCount
                }, window.location.origin);
                console.log('✅ [TRIGGER] PostMessage sent to opener window');
            }

            // Method 3: BroadcastChannel for modern browser support
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel('calendar_updates');
                channel.postMessage({
                    type: 'REFRESH_CALENDAR_GRID',
                    calendar_id: calendarId,
                    synced_count: syncedCount,
                    timestamp: Date.now()
                });
                channel.close();
                console.log('✅ [TRIGGER] BroadcastChannel message sent');
            }

            console.log('🎉 [TRIGGER] All calendar refresh triggers sent successfully');

        } catch (error) {
            console.error('❌ [TRIGGER] Error triggering calendar refresh:', error);
        }
    }

    // 현재 연결 중인 플랫폼과 선택된 캘린더를 저장
    let currentConnectingPlatform = null;
    let selectedCalendarId = null;

    // 개별 플랫폼 연동 기능 - 캘린더 선택 후 연결
    async function connectPlatform(platformName) {
        // Apple의 경우 스마트 마법사 실행
        if (platformName === 'apple') {
            if (window.appleWizard) {
                window.appleWizard.start(platformName);
            } else {
                console.error('Apple Setup Wizard not loaded');
                showNotification('Apple 설정 마법사를 불러오는 중 오류가 발생했습니다.', 'error');
                // 폴백으로 수동 설정 폼 표시
                togglePlatformDetails(platformName);
            }
            return;
        }

        // Google의 경우 새로운 Google Manager 사용
        if (platformName === 'google') {
            if (window.googleManager) {
                await window.googleManager.connect();
            } else {
                console.error('Google Manager not loaded');
                showNotification('Google Calendar Manager가 로드되지 않았습니다.', 'error');
            }
            return;
        }

        // OAuth 지원 플랫폼 체크
        const oauthPlatforms = ['notion', 'slack', 'outlook'];

        if (oauthPlatforms.includes(platformName)) {
            // OAuth 플랫폼의 경우 원클릭 연동 실행
            await oneClickConnect(platformName);
        } else {
            // 수동 설정 플랫폼의 경우 캘린더 선택 모달 표시
            await showCalendarSelectionModal(platformName);
        }
    }

    // 사용자 캘린더 목록 로드
    async function loadUserCalendars(container) {
        if (!container) {
            console.error('❌ [CALENDAR] Container element is null');
            return;
        }

        try {
            console.log('📅 [CALENDAR] Loading user calendars...');
            container.innerHTML = '<div class="loading-spinner">캘린더 목록을 불러오는 중...</div>';

            const response = await fetch('/api/calendars/list');
            const data = await response.json();

            if (data.success && data.calendars) {
                displayCalendarList(data.calendars, container);
                console.log('✅ [CALENDAR] Successfully loaded calendars:', data.calendars.length);
            } else {
                throw new Error(data.error || 'Failed to load calendars');
            }
        } catch (error) {
            console.error('❌ [CALENDAR] Failed to load calendars:', error);
            container.innerHTML = '<div class="error-message">캘린더 목록을 불러올 수 없습니다.</div>';
        }
    }

    // Legacy Google calendar loading functions removed - using GoogleCalendarManager instead

    // 새로운 Google/Notion 스타일 캘린더 선택 모달
    async function showCalendarSelectionModal(platformName) {
        console.log('📅 [MODAL] Showing new-style calendar selection modal for:', platformName);

        currentConnectingPlatform = platformName;

        // Google은 새로운 GoogleCalendarManager 사용
        if (platformName === 'google') {
            console.log('📅 [MODAL] Redirecting to GoogleCalendarManager');
            if (window.googleManager) {
                await window.googleManager.connect();
            }
            return;
        }

        // Notion은 새로운 NotionCalendarManager 사용
        if (platformName === 'notion') {
            console.log('📅 [MODAL] Redirecting to NotionCalendarManager');
            if (window.notionManager) {
                await window.notionManager.connect();
            }
            return;
        }

        // 기존 모달 제거
        const existingModal = document.getElementById('calendar-selection-modal');
        if (existingModal) existingModal.remove();

        try {
            // 캘린더 목록 불러오기
            const response = await fetch('/api/calendars');
            const data = await response.json();

            // API 응답 구조 확인
            const calendars = data.personal_calendars || data.calendars || [];

            if (!data.success || !calendars.length) {
                showNotification('NotionFlow 캘린더가 없습니다. 캘린더를 먼저 생성해주세요.', 'warning');
                return;
            }

            // 캘린더 아이템 생성 (Google/Notion 스타일)
            const calendarItems = calendars.map(cal => `
                <div class="calendar-item" onclick="selectCalendarForConnection('${cal.id}', '${cal.name}', '${platformName}')">
                    <div class="calendar-name">${cal.name}</div>
                    <div class="calendar-description">이벤트: ${cal.event_count || 0}개</div>
                    <div class="calendar-meta">NotionFlow Calendar</div>
                </div>
            `).join('');

            // 새로운 모달 HTML (Google/Notion 스타일)
            const modalHtml = `
                <div class="modal-overlay" id="calendar-selection-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>${getKoreanPlatformName(platformName)} 캘린더 선택</h2>
                            <button class="modal-close" onclick="closeCalendarSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p><strong>${getKoreanPlatformName(platformName)}</strong>과 동기화할 NotionFlow 캘린더를 선택하세요:</p>
                            <div class="calendar-list">
                                ${calendarItems}
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
            console.log('✅ [MODAL] New-style calendar modal shown for:', platformName);

        } catch (error) {
            console.error('❌ [MODAL] Failed to load calendars:', error);
            showNotification('캘린더 목록을 불러오는 중 오류가 발생했습니다.', 'error');
        }
    }

    // [REMOVED] Old deprecated openCalendarSyncModal function removed - using new implementation below

    // 캘린더 목록 표시
    function displayCalendarList(calendars, container) {
        // container가 null인지 확인
        if (!container) {
            console.error('❌ [CALENDAR] Container element is null - cannot display calendar list');
            console.trace('displayCalendarList called with null container');
            return;
        }

        console.log('📅 [CALENDAR] Displaying calendar list:', { calendars, container });
        container.innerHTML = '';

        if (!calendars || calendars.length === 0) {
            container.innerHTML = '<div class="no-calendars">사용 가능한 캘린더가 없습니다.</div>';
            return;
        }

        calendars.forEach(calendar => {
            const calendarItem = createCalendarItem(calendar);
            if (calendarItem) {
                container.appendChild(calendarItem);
            }
        });
    }

    // Legacy Google calendar display functions removed - using GoogleCalendarManager instead

    // 샘플 캘린더 데이터 표시 (API가 없는 경우)
    function displaySampleCalendars(container) {
        if (!container) {
            console.error('❌ [SAMPLE] Container is null - cannot display sample calendars');
            return;
        }

        console.log('📅 [SAMPLE] Displaying sample calendars');

        const sampleCalendars = [
            {
                id: 'main-calendar',
                name: '메인 캘린더',
                description: '기본 개인 캘린더',
                type: 'primary',
                color: '#3b82f6'
            },
            {
                id: 'work-calendar',
                name: '업무 캘린더',
                description: '업무 관련 일정 관리',
                type: 'personal',
                color: '#f59e0b'
            },
            {
                id: 'shared-calendar',
                name: '팀 공유 캘린더',
                description: '팀원들과 공유하는 캘린더',
                type: 'shared',
                color: '#10b981'
            }
        ];

        displayCalendarList(sampleCalendars, container);
    }

    // 캘린더가 없을 때 메시지 표시
    function displayNoCalendarsMessage(container) {
        if (!container) {
            console.error('❌ [NO-CALENDARS] Container is null - cannot display no calendars message');
            return;
        }

        console.log('📅 [NO-CALENDARS] Displaying no calendars message');

        container.innerHTML =
            '<div class="no-calendars-message">' +
            '<div class="no-calendars-icon">' +
            '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">' +
            '<path d="M8 2v4M16 2v4M3 10h18M5 4h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"/>' +
            '</svg>' +
            '</div>' +
            '<h4>캘린더가 없습니다</h4>' +
            '<p>먼저 캘린더를 생성해주세요.</p>' +
            '<button class="btn-primary" onclick="redirectToCalendarCreation()">' +
            '캘린더 생성하러 가기' +
            '</button>' +
            '</div>';
    }

    // 캘린더 아이템 생성
    function createCalendarItem(calendar) {
        const item = document.createElement('div');
        item.className = 'calendar-item';
        item.setAttribute('data-calendar-id', calendar.id);
        item.onclick = () => selectCalendarForModal(calendar.id);

        item.innerHTML =
            '<div class="calendar-radio"></div>' +
            '<div class="calendar-info">' +
            '<div class="calendar-name">' + (calendar.name || '') + '</div>' +
            '<div class="calendar-description">' + (calendar.description || '') + '</div>' +
            '</div>' +
            '<div class="calendar-type ' + (calendar.type || 'personal') + '">' + getCalendarTypeText(calendar.type) + '</div>';

        return item;
    }

    // 캘린더 타입 텍스트 반환
    function getCalendarTypeText(type) {
        switch (type) {
            case 'primary': return '기본';
            case 'shared': return '공유';
            case 'personal': return '개인';
            default: return '개인';
        }
    }

    // 모달에서 캘린더 선택
    function selectCalendarForModal(calendarId) {
        // 기존 선택 해제
        document.querySelectorAll('.calendar-item').forEach(item => {
            item.classList.remove('selected');
        });

        // 새 선택 적용
        const selectedItem = document.querySelector('[data-calendar-id="' + calendarId + '"]');
        if (selectedItem) {
            selectedItem.classList.add('selected');
            selectedCalendarId = calendarId;

            // 확인 버튼 활성화
            document.getElementById('confirm-calendar-selection').disabled = false;
        }
    }

    // 캘린더 선택 확인
    async function confirmCalendarSelection() {
        console.log(`📅 confirmCalendarSelection 호출: platform=${currentConnectingPlatform}, calendar=${selectedCalendarId}`);

        if (!selectedCalendarId || !currentConnectingPlatform) {
            console.warn('⚠️ 필수 정보 누락:', { selectedCalendarId, currentConnectingPlatform });
            showNotification('캘린더를 선택해주세요.', 'error');
            return;
        }

        // Google의 경우는 별도의 GoogleManager를 사용하므로 여기서는 처리하지 않음
        if (currentConnectingPlatform === 'google') {
            console.log('⚠️ [GOOGLE] Google Calendar should use GoogleManager, not confirmCalendarSelection()');
            return;
        }

        // 다른 플랫폼의 경우 기존 로직
        try {
            console.log(`🔗 플랫폼 연결 시작: ${currentConnectingPlatform} → ${selectedCalendarId}`);

            // 모달 닫기 전에 변수 저장 (closeCalendarSelectionModal이 값을 null로 초기화하기 때문)
            const platformName = currentConnectingPlatform;
            const calendarId = selectedCalendarId;

            closeCalendarSelectionModal();

            await performPlatformConnection(platformName, calendarId);
            console.log(`✅ 플랫폼 연결 완료: ${platformName}`);
        } catch (error) {
            console.error(`❌ 플랫폼 연결 실패: ${currentConnectingPlatform}`, error);
            showNotification(`연결 중 오류가 발생했습니다: ${error.message}`, 'error');
        }
    }

    // 첫 번째 showNotionFlowCalendarSelection 함수 제거됨 (중복으로 인한 충돌 방지)

    // Duplicate Google connection function removed - using GoogleCalendarManager instead

    // 실제 플랫폼 연결 수행
    async function performPlatformConnection(platformName, calendarId) {
        console.log(`🔗 performPlatformConnection 호출: ${platformName}, ${calendarId}`);

        // DOM 요소들을 안전하게 찾기
        const button = document.querySelector('[data-platform="' + platformName + '"] .platform-connect-btn');
        const card = document.querySelector('[data-platform="' + platformName + '"]');

        // 요소가 없으면 안전하게 처리
        if (!button || !card) {
            console.log(`⚠️ DOM 요소를 찾을 수 없음 - button: ${!!button}, card: ${!!card}`);
            // DOM 요소가 없어도 API 호출은 진행
            return await performDirectPlatformConnection(platformName, calendarId);
        }

        // DOM 요소들을 안전하게 찾기 (null 체크 포함)
        const loader = button ? button.querySelector('.connect-loader') : null;
        const buttonText = button ? button.querySelector('.connect-text') : null;
        const status = card ? card.querySelector('.platform-status') : null;

        // 버튼 상태 변경 (요소가 있을 때만)
        if (button) {
            button.disabled = true;
        }
        if (buttonText) {
            buttonText.textContent = '연결 중...';
        }
        if (loader) {
            loader.style.display = 'flex';
        }

        // 카드 애니메이션 (카드가 있을 때만)
        if (card) {
            card.style.transform = 'scale(1.02)';
            card.style.boxShadow = 'var(--shadow-lg)';
        }

        try {
            console.log(`✅ ${platformName} OAuth 완료, 기존 연동 로직 활용`);

            // OAuth가 이미 완료된 상태이므로 바로 연결 처리
            // 기존에 만들어둔 통합 동기화 API 호출

            console.log(`🔄 ${platformName} 동기화 시작...`);

            // 기존 통합 동기화 API 호출
            const syncResponse = await fetch('/api/unified-sync/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    platforms: [platformName],
                    options: {
                        target_calendar_id: calendarId,
                        direction: 'bidirectional',
                        scope: 'all'
                    }
                })
            });

            if (syncResponse.ok) {
                const syncResult = await syncResponse.json();
                console.log(`✅ ${platformName} 동기화 성공:`, syncResult);

                if (syncResult.success && syncResult.results && syncResult.results[platformName]?.success) {
                    const platformResult = syncResult.results[platformName];
                    console.log(`📊 ${platformName} 동기화 결과: ${platformResult.message}`);
                } else {
                    console.warn(`⚠️ ${platformName} 동기화 부분 실패:`, syncResult);
                }
            } else {
                console.warn(`⚠️ ${platformName} 동기화 API 호출 실패:`, syncResponse.status);
            }

            // 연결 성공 처리
            if (status) {
                status.className = 'platform-status connected';
                status.innerHTML = '<span class="status-dot"></span>연결됨';
            }

            // 버튼을 연결해제 버튼으로 변경
            if (button) {
                button.className = 'platform-disconnect-btn';
                button.setAttribute('onclick', 'disconnectPlatform(\'' + platformName + '\')');
            }
            if (buttonText) {
                buttonText.textContent = '연결 해제';
            }

            // 통계 및 플랫폼 상태 업데이트
            updateConnectionStats();

            // DB에서 최신 상태를 다시 가져와서 확실히 반영
            setTimeout(async () => {
                await updatePlatformStatus();
                console.log(`🔄 ${platformName} 상태 재확인 완료`);
            }, 1000);

            // 동기화 결과에 따른 알림
            if (syncResponse && syncResponse.ok) {
                const syncResult = await syncResponse.json();
                if (syncResult.success && syncResult.results && syncResult.results[platformName]?.success) {
                    const platformResult = syncResult.results[platformName];
                    showNotification(platformResult.message || `${getKoreanPlatformName(platformName)} 연결 및 동기화 완료!`, 'success');
                } else {
                    showNotification(`${getKoreanPlatformName(platformName)} 연결 완료! (일부 동기화 실패)`, 'warning');
                }
            } else {
                showNotification(`${getKoreanPlatformName(platformName)} 연결 완료!`, 'success');
            }
        } catch (error) {
            console.error('연결 중 오류:', error);
            showNotification('연결 중 오류가 발생했습니다.', 'error');
        }

        // 애니메이션 및 상태 복원
        setTimeout(() => {
            if (button) {
                button.disabled = false;
                if (button.className === 'platform-connect-btn') {
                    if (buttonText) buttonText.textContent = '연결하기';
                }
            }
            if (loader) {
                loader.style.display = 'none';
            }
            if (card) {
                card.style.transform = '';
                card.style.boxShadow = '';
            }
        }, 500);

        // 선택 상태 초기화
        selectedCalendarId = null;
        currentConnectingPlatform = null;
    }

    // DOM 요소 없이 직접 플랫폼 연결 수행 (OAuth 팝업용)
    async function performDirectPlatformConnection(platformName, calendarId) {
        console.log(`🚀 performDirectPlatformConnection 시작: ${platformName}, ${calendarId}`);

        try {
            console.log(`✅ ${platformName} OAuth 이미 완료됨, 동기화 실행`);

            // OAuth가 이미 완료된 상태이므로 바로 동기화 진행
            console.log(`🔄 ${platformName} 동기화 시작...`);

            // 기존 통합 동기화 API 호출
            const syncResponse = await fetch('/api/unified-sync/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    platforms: [platformName],
                    options: {
                        target_calendar_id: calendarId,
                        direction: 'bidirectional',
                        scope: 'all'
                    }
                })
            });

            let syncMessage = '';
            if (syncResponse.ok) {
                const syncResult = await syncResponse.json();
                console.log(`✅ ${platformName} 동기화 성공:`, syncResult);

                if (syncResult.success && syncResult.results && syncResult.results[platformName]?.success) {
                    const platformResult = syncResult.results[platformName];
                    syncMessage = platformResult.message || '';
                    console.log(`📊 ${platformName} 동기화 결과: ${syncMessage}`);
                } else {
                    console.warn(`⚠️ ${platformName} 동기화 부분 실패:`, syncResult);
                    syncMessage = ' (일부 동기화 실패)';
                }
            } else {
                console.warn(`⚠️ ${platformName} 동기화 API 호출 실패:`, syncResponse.status);
            }

            // 플랫폼 상태 업데이트 (DOM 요소 찾기 후)
            setTimeout(() => {
                markPlatformConnected(platformName);
                updatePlatformStatus(platformName, 'connected');
                updateConnectionStats();
                updatePlatformStatus();
            }, 100);

            // 동기화 결과에 따른 알림
            const finalMessage = syncMessage || `${getKoreanPlatformName(platformName)} 연결 및 동기화 완료!`;
            showNotification(finalMessage, syncMessage.includes('실패') ? 'warning' : 'success');
            return { success: true, message: finalMessage };
        } catch (error) {
            console.error(`❌ ${platformName} 연결 중 오류:`, error);
            showNotification('연결 중 오류가 발생했습니다.', 'error');
            return { success: false, message: error.message };
        } finally {
            // 선택 상태 초기화
            selectedCalendarId = null;
            currentConnectingPlatform = null;
        }
    }

    // 캘린더 선택 모달 닫기
    function closeCalendarSelectionModal() {
        const modal = document.getElementById('calendar-selection-modal');
        if (modal) {
            modal.remove(); // Google/Notion 스타일처럼 제거
        }

        // 선택 상태 초기화
        selectedCalendarId = null;
        currentConnectingPlatform = null;
        isGoogleSecondStep = false;
        console.log('🗑️ Calendar selection modal closed');
    }

    // 새로운 모달에서 캘린더 선택 및 연결 (Google/Notion 스타일)
    async function selectCalendarForConnection(calendarId, calendarName, platformName) {
        console.log(`📅 [MODAL] Selected calendar: ${calendarId} (${calendarName}) for platform: ${platformName}`);

        try {
            // 연결 API 호출
            const response = await fetch(`/api/platform/${platformName}/connect`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    notionflow_calendar_id: calendarId
                })
            });

            const result = await response.json();

            if (result.success) {
                console.log(`✅ [MODAL] ${platformName} connection successful!`);

                // 모달 닫기
                closeCalendarSelectionModal();

                // 성공 알림
                showNotification(`${getKoreanPlatformName(platformName)}이 "${calendarName}" 캘린더와 성공적으로 연결되었습니다!`, 'success');

                // UI 업데이트
                markPlatformConnected(platformName);
                updatePlatformStatus();

            } else {
                throw new Error(result.error || '연결에 실패했습니다.');
            }

        } catch (error) {
            console.error(`❌ [MODAL] ${platformName} connection failed:`, error);
            showNotification(`연결 실패: ${error.message}`, 'error');
        }
    }

    // 캘린더 생성 페이지로 리다이렉트
    function redirectToCalendarCreation() {
        closeCalendarSelectionModal();
        window.location.href = '/calendar';
    }
    // END OF DEPRECATED FUNCTIONS

    // 개별 플랫폼 연결 해제 기능
    async function disconnectPlatform(platformName) {
        const card = document.querySelector(`[data-platform="${platformName}"]`);
        const button = card?.querySelector('.platform-disconnect-btn');
        const loader = button?.querySelector('.disconnect-loader');
        const buttonText = button?.querySelector('.disconnect-text');
        const status = card?.querySelector('.platform-status');

        if (!card || !button) {
            console.error(`Cannot find disconnect button for platform: ${platformName}`);
            return;
        }

        if (!confirm(getKoreanPlatformName(platformName) + ' 연결을 해제하시겠습니까?')) {
            return;
        }

        // 버튼 상태 변경
        button.disabled = true;
        if (buttonText) buttonText.textContent = '해제 중...';
        if (loader) loader.style.display = 'flex';

        try {
            // 백엔드에 연결 해제 요청
            const response = await fetch('/api/calendar/disconnect-platform', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ platform: platformName })
            });

            const result = await response.json();
            if (!result.success) {
                throw new Error(result.error || '연결 해제 실패');
            }

            console.log(`✅ ${platformName} 연결 해제 완료:`, result);

            // 상태 업데이트
            status.className = 'platform-status disconnected';
            status.innerHTML = '<span class="status-dot"></span>연결되지 않음';

            // 버튼을 연결 버튼으로 변경
            button.className = 'platform-connect-btn';
            button.setAttribute('onclick', `connectPlatform('${platformName}')`);
            buttonText.textContent = '연결하기';

            // 통계 및 플랫폼 상태 업데이트
            updateConnectionStats();
            updatePlatformStatus();

            showNotification(`${getKoreanPlatformName(platformName)} 연결 해제 완료`, 'success');
        } catch (error) {
            console.error('연결 해제 중 오류:', error);
            showNotification('연결 해제 중 오류가 발생했습니다.', 'error');
        }

        // 상태 복원
        setTimeout(() => {
            button.disabled = false;
            if (button.className === 'platform-disconnect-btn') {
                if (buttonText) buttonText.textContent = '연결 해제';
            }
            if (loader) loader.style.display = 'none';
        }, 500);
    }


    // 플랫폼 이름 한국어 변환
    function getKoreanPlatformName(platform) {
        const names = {
            'notion': 'Notion',
            'google': 'Google Calendar',
            'apple': 'Apple Calendar',
            'outlook': 'Outlook',
            'slack': 'Slack'
        };
        return names[platform] || platform;
    }

    // 알림 표시 함수 - NotificationUtils 사용
    function showNotification(message, type = 'info') {
        if (window.NotificationUtils) {
            return window.NotificationUtils.show(message, type);
        }
        // Fallback if NotificationUtils not loaded
        console.log(`[${type}] ${message}`);
    }

    // 실제 플랫폼 연결 상태 업데이트 (API 호출)
    async function updateAllPlatformStatus() {
        try {
            console.log('🔍 [DEBUG] updatePlatformStatus 호출됨');
            const response = await fetch('/api/dashboard/platforms');

            if (response.ok) {
                const data = await response.json();
                console.log('🔍 [DEBUG] 플랫폼 상태 API 응답:', data);
                console.log('🔍 [DEBUG] Notion 상태 상세:', data.platforms?.notion);

                if (data.success && data.platforms) {
                    const platforms = data.platforms;
                    console.log('🔍 [DEBUG] 플랫폼 데이터:', platforms);

                    // 각 플랫폼별 상태 업데이트
                    Object.keys(platforms).forEach(platformName => {
                        const platform = platforms[platformName];
                        const platformCard = document.querySelector(`[data-platform="${platformName}"]`);

                        console.log(`🔍 [DEBUG] ${platformName} 상태:`, {
                            configured: platform.configured,
                            oauth_connected: platform.oauth_connected,
                            has_credentials: platform.has_credentials,
                            oauth_source: platform.oauth_source
                        });

                        if (platformCard) {
                            const statusElement = platformCard.querySelector('.platform-status');
                            const connectBtn = platformCard.querySelector('.platform-connect-btn');

                            const syncBtn = platformCard.querySelector('.platform-sync-btn');

                            // OAuth 연결됨 또는 설정 완료됨
                            if (statusElement && (platform.configured || platform.oauth_connected)) {
                                console.log(`✅ [DEBUG] ${platformName} 연결 상태 복원:`, platform);

                                // 연결된 상태로 표시
                                statusElement.className = 'platform-status connected';
                                statusElement.innerHTML = '<span class="status-dot"></span>연결됨';

                                // 연결 버튼을 연결해제 버튼으로 변경 (숨기지 말고)
                                if (connectBtn) {
                                    connectBtn.className = 'platform-disconnect-btn';
                                    connectBtn.setAttribute('onclick', `disconnectPlatform('${platformName}')`);
                                    const buttonText = connectBtn.querySelector('.connect-text');
                                    if (buttonText) {
                                        buttonText.textContent = '연결 해제';
                                    }
                                }

                                // 원클릭 버튼도 연결 상태에 따라 업데이트
                                const oneClickBtn = platformCard.querySelector('.one-click-btn-small');
                                if (oneClickBtn && platformName !== 'google') {
                                    const buttonText = oneClickBtn.querySelector('.btn-text');
                                    if (buttonText) {
                                        buttonText.textContent = '연결해제';
                                    }
                                    oneClickBtn.setAttribute('onclick', `oneClickDisconnect('${platformName}')`);
                                }

                                // Google은 별도 처리 (markPlatformConnected 함수 사용)
                                if (platformName === 'google') {
                                    markPlatformConnected(platformName);
                                }
                            } else {
                                // 연결되지 않은 상태
                                console.log(`❌ ${platformName} 연결되지 않음:`, platform);

                                statusElement.className = 'platform-status disconnected';
                                statusElement.innerHTML = '<span class="status-dot"></span>연결되지 않음';

                                // 연결 버튼 복원
                                if (connectBtn) {
                                    connectBtn.style.display = 'inline-block';
                                    connectBtn.className = 'platform-connect-btn';
                                    connectBtn.setAttribute('onclick', `connectPlatform('${platformName}')`);
                                }

                                // 원클릭 버튼 복원
                                const oneClickBtn = platformCard.querySelector('.one-click-btn-small');
                                if (oneClickBtn && platformName !== 'apple') { // Apple은 원클릭 버튼 없음
                                    const buttonText = oneClickBtn.querySelector('.btn-text');
                                    if (buttonText) {
                                        buttonText.textContent = '원클릭';
                                    }
                                    oneClickBtn.setAttribute('onclick', `oneClickConnect('${platformName}')`);
                                    oneClickBtn.className = 'one-click-btn-small';
                                    oneClickBtn.style.display = 'inline-block';
                                }

                                // Google 연결해제 버튼 제거
                                const googleDisconnectBtn = platformCard.querySelector('.google-disconnect-btn');
                                if (googleDisconnectBtn) {
                                    googleDisconnectBtn.remove();
                                }

                                // 캘린더 연동 버튼 숨기기
                                if (syncBtn) {
                                    syncBtn.style.display = 'none';
                                }
                            }
                        }
                    });

                    console.log('Platform status updated with real data:', platforms);
                }
            }
        } catch (error) {
            console.error('🔍 [DEBUG] Error updating platform status:', error);
            console.error('🔍 [DEBUG] Error details:', error.message, error.stack);
            // API 에러 시 모든 플랫폼을 연결되지 않은 상태로 설정
            const platformCards = document.querySelectorAll('.platform-card');
            platformCards.forEach(card => {
                const statusElement = card.querySelector('.platform-status');
                if (statusElement) {
                    statusElement.className = 'platform-status disconnected';
                    statusElement.innerHTML = '<span class="status-dot"></span>연결되지 않음';
                }
            });
        }
    }

    // 캘린더 개수 확인 및 플랫폼 카드 상태 업데이트
    async function checkCalendarsAndUpdatePlatforms() {
        try {
            // 서버에서 렌더링된 통계 데이터 사용
            const connectedCount = {{ (stats.connected_count if stats and stats.connected_count else 0) | tojson }};
    const hasCalendars = connectedCount > 0;

    // 모든 플랫폼 카드 선택
    const platformCards = document.querySelectorAll('.platform-card');

    platformCards.forEach(card => {
        if (!hasCalendars) {
            // 캘린더가 없으면 카드 비활성화
            card.classList.add('disabled');

            // 안내 메시지 추가 (아직 없으면)
            if (!card.querySelector('.no-calendar-notice')) {
                const notice = document.createElement('div');
                notice.className = 'no-calendar-notice';
                notice.innerHTML = '<div class="no-calendar-notice-text">📅 먼저 캘린더를 생성해주세요</div>';
                card.appendChild(notice);
            }

            // 버튼들 비활성화
            const buttons = card.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.pointerEvents = 'none';
            });
        } else {
            // 캘린더가 있으면 카드 활성화
            card.classList.remove('disabled');

            // 안내 메시지 제거
            const notice = card.querySelector('.no-calendar-notice');
            if (notice) {
                notice.remove();
            }

            // 버튼들 활성화
            const buttons = card.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = false;
                btn.style.pointerEvents = '';
            });
        }
    });

    return hasCalendars;
        } catch (error) {
        // 에러 시 기본적으로 비활성화 (조용히)
        const platformCards = document.querySelectorAll('.platform-card');
        platformCards.forEach(card => {
            card.classList.add('disabled');
        });
        return false;
    }
    }

    // 페이지 로드 시 통계 업데이트
    document.addEventListener('DOMContentLoaded', async function () {
        // Check if we just came back from Google OAuth
        const urlParams = new URLSearchParams(window.location.search);
        const fromOAuth = urlParams.get('from_oauth') || document.referrer.includes('/auth/google/callback');
        if (fromOAuth) {
            console.log('Detected Google OAuth completion - setting flag');
            sessionStorage.setItem('google_oauth_completed', 'true');
            // Clean up URL
            if (urlParams.get('from_oauth')) {
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }

        try {
            // 초기 로드 (조용히)
            await checkCalendarsAndUpdatePlatforms();
            await updatePlatformStatus();
            await updateConnectionStats();
            // 통계 업데이트 후 가이드 체크
            checkAndHideGuide();
        } catch (error) {
            // 에러 시 기본값 설정 (조용히)
            const connectedCountEl = document.getElementById('connected-count');
            const syncCountEl = document.getElementById('sync-count');
            const successRateEl = document.getElementById('success-rate');
            const syncSpeedEl = document.getElementById('sync-speed');

            if (connectedCountEl) connectedCountEl.textContent = '0';
            if (syncCountEl) syncCountEl.textContent = '0';
            if (successRateEl) successRateEl.textContent = '0%';
            if (syncSpeedEl) syncSpeedEl.textContent = 'N/A';
            // 에러 시에도 가이드 체크
            checkAndHideGuide();
        }

        // 30초마다 업데이트 (조용히)
        setInterval(async () => {
            try {
                await checkCalendarsAndUpdatePlatforms();
                await updatePlatformStatus();
                await updateConnectionStats();
            } catch (error) {
                // 에러 무시 (조용히)
            }
        }, 30000);

        // 탭 포커스 시 업데이트 (조용히)
        document.addEventListener('visibilitychange', async function () {
            if (!document.hidden) {
                try {
                    await checkCalendarsAndUpdatePlatforms();
                    await updatePlatformStatus();
                    await updateConnectionStats();
                } catch (error) {
                    // 에러 무시 (조용히)
                }
            }
        });
    });

    async function updateConnectionStats() {
        try {
            // 서버에서 렌더링된 데이터 사용 (조용히)
            const stats = {
                connected_count: {{ (stats.connected_count if stats and stats.connected_count else 0) | tojson }},
                synced_events: {{ (stats.synced_events if stats and stats.synced_events else 0) | tojson }},
                success_rate: {{ (stats.success_rate if stats and stats.success_rate else "0%") | tojson }},
                avg_sync_time: {{ (stats.avg_sync_time if stats and stats.avg_sync_time else "N/A") | tojson }}
            };

    // DOM 업데이트 (null 체크 포함)
    const connectedCountEl = document.getElementById('connected-count');
    const syncCountEl = document.getElementById('sync-count');
    const successRateEl = document.getElementById('success-rate');
    const syncSpeedEl = document.getElementById('sync-speed');

    if (connectedCountEl) connectedCountEl.textContent = stats.connected_count;
    if (syncCountEl) syncCountEl.textContent = stats.synced_events;
    if (successRateEl) successRateEl.textContent = stats.success_rate;
    if (syncSpeedEl) syncSpeedEl.textContent = stats.avg_sync_time;
        } catch (error) {
        // 에러 시 기본값 설정 (조용히)
        const connectedCountEl = document.getElementById('connected-count');
        const syncCountEl = document.getElementById('sync-count');
        const successRateEl = document.getElementById('success-rate');
        const syncSpeedEl = document.getElementById('sync-speed');

        if (connectedCountEl) connectedCountEl.textContent = '0';
        if (syncCountEl) syncCountEl.textContent = '0';
        if (successRateEl) successRateEl.textContent = '0%';
        if (syncSpeedEl) syncSpeedEl.textContent = 'N/A';
    }
    }

    // 개별 플랫폼 원클릭 연동 기능
    async function oneClickConnect(platform) {
        // Apple의 경우 스마트 마법사 실행
        if (platform === 'apple') {
            const button = document.querySelector(`[data-platform="${platform}"] .one-click-btn-small`);

            if (button) {
                const loader = button.querySelector('.btn-loader');
                const buttonText = button.querySelector('.btn-text');

                // 버튼 상태 변경
                button.disabled = true;
                if (buttonText) buttonText.style.display = 'none';
                if (loader) loader.style.display = 'flex';

                // 잠깐 로딩 표시 후 마법사 실행
                setTimeout(() => {
                    button.disabled = false;
                    if (buttonText) buttonText.style.display = 'inline';
                    if (loader) loader.style.display = 'none';
                }, 500);
            }

            if (window.appleWizard) {
                window.appleWizard.start(platform);
            } else {
                console.error('Apple Setup Wizard not loaded');
                showNotification('Apple 설정 마법사를 불러오는 중 오류가 발생했습니다.', 'error');
            }
            return;
        }

        // Google의 경우 새로운 Google Manager 사용
        if (platform === 'google') {
            if (window.googleManager) {
                await window.googleManager.connect();
            } else {
                console.error('Google Manager not loaded');
                showNotification('Google Calendar Manager가 로드되지 않았습니다.', 'error');
            }
            return;
        }

        const button = document.querySelector(`[data-platform="${platform}"] .one-click-btn-small`);

        if (!button) {
            console.error(`Button not found for platform: ${platform}`);
            showNotification(`${getKoreanPlatformName(platform)} 연결 버튼을 찾을 수 없습니다.`, 'error');
            return;
        }

        const loader = button.querySelector('.btn-loader');
        const buttonText = button.querySelector('.btn-text');

        // 버튼 상태 변경
        button.disabled = true;
        if (buttonText) buttonText.style.display = 'none';
        if (loader) loader.style.display = 'flex';

        try {
            // OAuth 지원 플랫폼들 (Google 제외)
            const oauthPlatforms = ['notion', 'slack', 'outlook'];

            if (oauthPlatforms.includes(platform)) {
                // OAuth 플로우 실행
                await performOAuthConnection(platform);
            } else {
                // 일반 API 키 방식
                showNotification(`${getKoreanPlatformName(platform)} 연결을 위해 설정 폼을 작성해주세요.`, 'info');
                togglePlatformDetails(platform);
            }

        } catch (error) {
            console.error(`${platform} 연동 중 오류:`, error);
            showNotification(`${getKoreanPlatformName(platform)} 연동 중 오류가 발생했습니다.`, 'error');
        } finally {
            // 버튼 상태 복원
            setTimeout(() => {
                button.disabled = false;
                if (buttonText) buttonText.style.display = 'inline';
                if (loader) loader.style.display = 'none';
            }, 1000);
        }
    }

    // Google Calendar 연결 처리 함수 (DEPRECATED - 새로운 Google Manager 사용)
    async function handleGoogleConnect() {
        console.log('⚠️ [GOOGLE] handleGoogleConnect is deprecated, using Google Manager instead');
        if (window.googleManager) {
            await window.googleManager.connect();
        } else {
            console.error('Google Manager not available');
            showNotification('Google Calendar Manager가 로드되지 않았습니다.', 'error');
        }
    }

    // Deprecated OAuth functions removed - using GoogleCalendarManager instead

    // Old Google calendar selection functions removed - using GoogleCalendarManager instead

    // Old NotionFlow selection functions removed - using GoogleCalendarManager instead

    // OAuth 연결 수행
    async function performOAuthConnection(platform) {
        try {
            // OAuth 설정 확인
            const configCheck = await fetch(`/oauth/${platform}/check`);
            const configData = await configCheck.json();

            if (!configData.configured) {
                showNotification(
                    `${getKoreanPlatformName(platform)} OAuth가 설정되지 않았습니다. 수동 설정을 사용해주세요.`,
                    'warning'
                );
                // 수동 설정 폼 표시
                togglePlatformDetails(platform);
                return;
            }

            const width = 500;
            const height = 700;
            const left = (screen.width - width) / 2;
            const top = (screen.height - height) / 2;

            const popup = window.open(
                `/oauth/${platform}/authorize`,
                `oauth_${platform}`,
                `width=${width},height=${height},left=${left},top=${top},scrollbars=yes,resizable=yes`
            );

            if (!popup) {
                throw new Error('팝업이 차단되었습니다. OAuth 인증을 위해 팝업을 허용해주세요.');
            }

            // OAuth 완료 대기 - 더 긴 타임아웃으로 API 처리 시간 확보
            return new Promise((resolve, reject) => {
                const checkInterval = 500;
                let timeoutCount = 0;
                const maxTimeout = 360; // 3분 타임아웃 (API 응답 대기 시간 확보)

                // 팝업으로부터 메시지 수신 대기
                const messageHandler = (event) => {
                    if (event.origin !== window.location.origin) {
                        return;
                    }

                    if (event.data && event.data.type) {
                        if (event.data.type === 'oauth_success') {
                            cleanup();

                            // Google의 경우 캘린더 선택 팝업을 표시
                            if (event.data.platform === 'google') {
                                console.log('📅 Google OAuth 성공 처리 중...');

                                // 먼저 플랫폼을 연결된 상태로 표시 (연결해제 버튼 생성)
                                markPlatformConnected(event.data.platform);
                                updatePlatformStatus(event.data.platform, 'connected');
                                updateConnectionStats();
                                updatePlatformStatus();

                                // Google Calendar 선택 팝업 표시
                                setTimeout(async () => {
                                    try {
                                        console.log('📅 Google 캘린더 선택 모달 표시...');
                                        await showCalendarSelectionModal('google');
                                        showNotification('Google Calendar 연결이 완료되었습니다!', 'success');
                                    } catch (error) {
                                        console.error('Google Calendar 선택 오류:', error);
                                        showNotification('Google Calendar 선택 중 오류가 발생했습니다.', 'error');
                                    }
                                }, 500);

                                resolve(event.data);
                            } else if (event.data.platform === 'notion') {
                                // Notion의 경우 새로운 NotionCalendarManager 사용
                                console.log('📅 Notion OAuth 성공 처리 중...');

                                markPlatformConnected(event.data.platform);
                                updatePlatformStatus(event.data.platform, 'connected');
                                showNotification('Notion 연결이 완료되었습니다! 캘린더를 선택해주세요.', 'success');
                                updateConnectionStats();
                                updatePlatformStatus();

                                // 새로운 Notion Manager 사용
                                setTimeout(async () => {
                                    try {
                                        console.log('📅 [NOTION] Using new NotionCalendarManager...');

                                        if (window.notionManager) {
                                            await window.notionManager.connect();
                                        } else {
                                            console.error('❌ [NOTION] NotionCalendarManager not found');
                                            showNotification('Notion 캘린더 매니저를 찾을 수 없습니다.', 'error');
                                        }

                                    } catch (modalError) {
                                        console.error('❌ [NOTION] 캘린더 선택 모달 오류:', modalError);
                                        showNotification('캘린더 선택 모달을 여는 중 오류가 발생했습니다.', 'error');
                                    }
                                }, 500);

                                resolve(event.data);
                            } else {
                                // 다른 플랫폼의 경우 기존 로직 유지
                                markPlatformConnected(event.data.platform);
                                updatePlatformStatus(event.data.platform, 'connected');
                                showNotification(`${getKoreanPlatformName(event.data.platform)} 연결이 완료되었습니다!`, 'success');
                                updateConnectionStats();
                                updatePlatformStatus();
                                resolve(event.data);
                            }
                        } else if (event.data.type === 'oauth_error') {
                            cleanup();
                            console.error(`OAuth Error for ${platform}:`, event.data);

                            // 더 구체적인 에러 메시지 제공
                            let errorMessage = event.data.error || 'OAuth 인증에 실패했습니다';
                            if (errorMessage.includes('Failed to exchange authorization code for tokens')) {
                                errorMessage = 'API 응답이 지연되고 있습니다. 잠시 후 다시 시도해주세요.';
                            } else if (errorMessage.includes('authorization_code') && errorMessage.includes('expired')) {
                                errorMessage = 'OAuth 코드가 만료되었습니다. 다시 연결해주세요.';
                            } else if (errorMessage.includes('invalid_grant') || errorMessage.includes('expired')) {
                                errorMessage = 'OAuth 코드가 만료되었습니다. 다시 연결해주세요.';
                            } else if (errorMessage.includes('timeout')) {
                                errorMessage = '연결 시간이 초과되었습니다. 네트워크 상태를 확인하고 다시 시도해주세요.';
                            } else if (errorMessage.includes('rate limit')) {
                                errorMessage = 'API 요청 한도에 도달했습니다. 1분 후 다시 시도해주세요.';
                            } else if (errorMessage.includes('access_denied')) {
                                errorMessage = '사용자가 OAuth 인증을 취소했습니다.';
                            } else if (errorMessage.includes('Cross-Origin')) {
                                errorMessage = '브라우저 정책으로 인한 일시적 오류입니다. 다시 시도해주세요.';
                            }

                            showNotification(`연결 실패: ${errorMessage}`, 'error');
                            reject(new Error(errorMessage));
                        }
                    }
                };

                // 팝업 닫힘 감지 (Cross-Origin Policy 문제 해결)
                const checkClosed = setInterval(() => {
                    try {
                        // popup.closed 접근을 try-catch로 감싸서 Cross-Origin Policy 오류 방지
                        if (popup.closed) {
                            cleanup();
                            reject(new Error('OAuth 인증이 취소되었습니다'));
                            return;
                        }
                    } catch (e) {
                        // Cross-Origin Policy로 popup.closed에 접근할 수 없는 경우
                        // 이는 보통 팝업이 다른 도메인으로 이동했음을 의미하므로 정상적인 상황
                        console.log('팝업이 OAuth 페이지로 이동했습니다 (정상)');
                    }

                    timeoutCount++;
                    if (timeoutCount >= maxTimeout) {
                        cleanup();
                        try {
                            if (!popup.closed) {
                                popup.close();
                            }
                        } catch (e) {
                            // popup.close() 실패 시에도 처리 계속
                            console.log('팝업 닫기 실패 (이미 닫혔을 수 있음)');
                        }
                        reject(new Error('OAuth 인증 시간이 초과되었습니다. API 서버 응답이 지연되고 있을 수 있습니다. 잠시 후 다시 시도해주세요.'));
                    }
                }, checkInterval);

                const cleanup = () => {
                    console.log('🧹 OAuth 팝업 cleanup 시작...');


                    window.removeEventListener('message', messageHandler);
                    clearInterval(checkClosed);
                    try {
                        // Cross-Origin Policy로 popup.closed 접근이 차단될 수 있음
                        if (popup && !popup.closed) {
                            popup.close();
                        }
                    } catch (e) {
                        // Cross-Origin 제한으로 popup 상태 확인 불가능한 경우
                        console.log('팝업 정리 중 Cross-Origin 제한 (정상):', e.message);
                        try {
                            // 그래도 닫기 시도
                            popup.close();
                        } catch (closeError) {
                            console.log('팝업 닫기 최종 시도 실패 (정상)');
                        }
                    }
                };

                window.addEventListener('message', messageHandler);
            });
        } catch (error) {
            console.error('OAuth 연결 실패:', error);
            throw error;
        }
    }

    // 플랫폼 상태 업데이트
    function updatePlatformStatus(platform, status) {
        const card = document.querySelector(`[data-platform="${platform}"]`);
        if (!card) return;

        const statusElement = card.querySelector('.platform-status');
        const connectBtn = card.querySelector('.platform-connect-btn');
        const disconnectBtn = card.querySelector('.platform-disconnect-btn');
        const syncBtn = card.querySelector('.platform-sync-btn');

        if (status === 'connected') {
            statusElement.className = 'platform-status connected';
            statusElement.innerHTML = '<span class="status-dot"></span>연결됨';

            // 기존 연결 버튼 숨기기 (원클릭 버튼이 연결해제 역할을 함)
            if (connectBtn) {
                connectBtn.style.display = 'none';
            }

            // 원클릭 버튼을 연결해제 버튼으로 변경
            const oneClickBtn = card.querySelector('.one-click-btn-small');
            if (oneClickBtn) {
                // Google Calendar의 경우 작은 버튼 숨기고 연결해제 버튼만 추가
                if (platform === 'google') {
                    // Google Calendar의 경우 연결해제 버튼을 추가
                    const actionContainer = oneClickBtn.parentElement;
                    const syncBtn = card.querySelector('.platform-sync-btn');

                    // Google 연결해제 버튼은 markPlatformConnected 함수에서만 생성 (중복 방지)

                    // 원클릭 버튼은 숨기기
                    oneClickBtn.style.display = 'none';
                } else {
                    // 다른 플랫폼은 기존 로직 유지
                    oneClickBtn.className = 'one-click-disconnect-btn';
                    oneClickBtn.setAttribute('onclick', `oneClickDisconnect('${platform}')`);
                    oneClickBtn.innerHTML = `
                        <span class="btn-text">연결해제</span>
                        <div class="btn-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                        </div>
                    `;
                }
            }

            // 캘린더 변경 버튼 표시 (이미 연결되어 있어도 변경 가능)
            if (syncBtn) {
                syncBtn.style.display = 'block';
                const syncText = syncBtn.querySelector('.sync-text');
                if (syncText) {
                    if (syncText) syncText.textContent = '캘린더 변경';
                }
            }
        } else {
            statusElement.className = 'platform-status disconnected';
            statusElement.innerHTML = '<span class="status-dot"></span>연결되지 않음';

            // 연결 버튼을 다시 표시
            if (connectBtn) {
                connectBtn.style.display = 'inline-flex';
            }

            // 연결해제 버튼 숨기기
            if (disconnectBtn) {
                disconnectBtn.style.display = 'none';
            }

            // 원클릭 버튼을 원래 상태로 되돌리기
            const oneClickDisconnectBtn = card.querySelector('.one-click-disconnect-btn');
            const oneClickChangeBtn = card.querySelector('.one-click-change-btn');
            const googleDisconnectBtn = card.querySelector('.google-disconnect-btn');

            // Google Calendar의 경우 추가 버튼들 정리
            if (platform === 'google') {
                // 숨겨진 원클릭 버튼을 다시 표시
                const oneClickBtn = card.querySelector('.one-click-btn-small');
                if (oneClickBtn) {
                    oneClickBtn.style.display = 'inline-flex';
                }

                // Google 전용 연결해제 버튼 제거
                if (googleDisconnectBtn) {
                    googleDisconnectBtn.remove();
                }
            } else {
                // 다른 플랫폼은 기존 로직 유지
                if (oneClickDisconnectBtn) {
                    oneClickDisconnectBtn.className = 'one-click-btn-small';
                    oneClickDisconnectBtn.setAttribute('onclick', `oneClickConnect('${platform}')`);
                    oneClickDisconnectBtn.innerHTML = `
                        <span class="btn-text">원클릭</span>
                        <div class="btn-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                        </div>
                    `;
                }
            }

            // 연결되지 않은 상태에서는 캘린더 연동 버튼 숨기기
            const syncBtn = card.querySelector('.platform-sync-btn');
            if (syncBtn) {
                syncBtn.style.display = 'none';
            }
        }
    }

    // 플랫폼 세부사항 토글
    function togglePlatformDetails(platform) {
        const details = document.getElementById(`${platform}-details`);
        if (details) {
            const isVisible = details.style.display !== 'none';
            details.style.display = isVisible ? 'none' : 'block';

            const expandBtn = document.querySelector(`[data-platform="${platform}"] .platform-expand-btn`);
            if (expandBtn) {
                expandBtn.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
            }
        }
    }

    // 캘린더 연동 모달 열기

    // 캘린더 선택
    window.selectedCalendarId = null;
    window.selectedCalendarName = null;

    function selectCalendar(calendarId, calendarName) {
        // 이전 선택 해제
        document.querySelectorAll('.calendar-card').forEach(card => {
            card.classList.remove('selected');
        });

        // 새 선택 적용
        const selectedCard = document.querySelector(`[data-calendar-id="${calendarId}"]`);
        if (selectedCard) {
            selectedCard.classList.add('selected');
        }

        window.selectedCalendarId = calendarId;
        window.selectedCalendarName = calendarName;

        // 다음 버튼 활성화
        const nextBtn = document.getElementById('next-step-btn');
        if (nextBtn) {
            nextBtn.disabled = false;
        }
    }

    // 다음 단계로 이동
    function nextSyncStep() {
        const currentStep = document.querySelector('.step.active');
        const currentStepNumber = parseInt(currentStep.dataset.step);

        if (currentStepNumber === 1) {
            // 1단계 → 2단계
            currentStep.classList.remove('active');
            document.querySelector('[data-step="2"]').classList.add('active');

            document.getElementById('step1').classList.add('hidden');
            document.getElementById('step2').classList.remove('hidden');

            // 선택된 캘린더 미리보기 업데이트
            const preview = document.getElementById('selected-calendar-preview');
            if (preview && window.selectedCalendarName) {
                preview.innerHTML = `
                    <div class="calendar-preview">
                        <h6>${window.selectedCalendarName}</h6>
                        <p>선택된 캘린더입니다.</p>
                    </div>
                `;
            }

            // 버튼 상태 변경
            document.getElementById('next-step-btn').classList.add('hidden');
            document.getElementById('sync-btn').classList.remove('hidden');

        } else if (currentStepNumber === 2) {
            // 2단계 → 3단계는 performSync에서 처리
        }
    }

    // 연동 수행
    async function performSync(platform) {
        if (!window.selectedCalendarId) {
            showNotification('캘린더를 선택해주세요.', 'error');
            return;
        }

        const syncBtn = document.getElementById('sync-btn');
        const originalText = syncBtn.textContent;

        try {
            syncBtn.disabled = true;
            syncBtn.innerHTML = '<div class="loader-spinner"></div> 연동 중...';

            // 연동 API 호출
            const response = await fetch('/api/calendar/connect-platform', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    platform: platform,
                    calendar_id: window.selectedCalendarId,
                    import_existing: document.getElementById('import-existing')?.checked || false,
                    real_time_sync: document.getElementById('real-time-sync')?.checked || true
                })
            });

            const result = await response.json();

            if (result.success) {
                // 3단계로 이동
                document.querySelector('.step.active').classList.remove('active');
                document.querySelector('[data-step="3"]').classList.add('active');

                document.getElementById('step2').classList.add('hidden');
                document.getElementById('step3').classList.remove('hidden');

                // 완료 정보 업데이트
                const syncedCalendarNameEl = document.getElementById('synced-calendar-name');
                if (syncedCalendarNameEl) syncedCalendarNameEl.textContent = window.selectedCalendarName;

                // 버튼 상태 변경
                document.getElementById('sync-btn').classList.add('hidden');
                document.getElementById('complete-btn').classList.remove('hidden');

                // 플랫폼 상태 업데이트
                updatePlatformSyncStatus(platform, window.selectedCalendarName);

                showNotification(`${platform} 연동이 완료되었습니다!`, 'success');
            } else {
                throw new Error(result.error || '연동 실패');
            }

        } catch (error) {
            console.error('Sync error:', error);
            showNotification(`연동 실패: ${error.message}`, 'error');

            syncBtn.disabled = false;
            if (syncBtn) syncBtn.textContent = originalText;
        }
    }

    // 연동 상태 업데이트
    function updatePlatformSyncStatus(platform, calendarName) {
        const card = document.querySelector(`[data-platform="${platform}"]`);
        if (!card) return;

        const syncBtn = card.querySelector('.platform-sync-btn');
        if (syncBtn) {
            const syncText = syncBtn.querySelector('.sync-text');
            if (syncText) {
                if (syncText) syncText.textContent = `연동됨: ${calendarName}`;
                syncBtn.classList.add('synced');
                syncBtn.title = `${calendarName}과 연동됨`;
            }

            // X 버튼 추가 제거 - 연결해제 버튼이 이미 별도로 있음
            // 중복 버튼 생성 방지
        }
    }

    // 연동 해제
    async function disconnectPlatformSync(platform) {
        if (!confirm(`${platform} 캘린더 연동을 해제하시겠습니까?`)) {
            return;
        }

        try {
            const response = await fetch('/api/calendar/disconnect-platform', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ platform: platform })
            });

            const result = await response.json();

            if (result.success) {
                // UI 상태 되돌리기
                const card = document.querySelector(`[data-platform="${platform}"]`);
                const syncBtn = card?.querySelector('.platform-sync-btn');
                if (syncBtn) {
                    const syncText = syncBtn.querySelector('.sync-text');
                    if (syncText) {
                        if (syncText) syncText.textContent = '캘린더 연동';
                    }
                    syncBtn.classList.remove('synced');
                    syncBtn.title = '';

                    const disconnectBtn = syncBtn.querySelector('.sync-disconnect-btn');
                    if (disconnectBtn) {
                        disconnectBtn.remove();
                    }
                }

                showNotification(`${platform} 연동이 해제되었습니다.`, 'success');
            } else {
                throw new Error(result.error || '연동 해제 실패');
            }

        } catch (error) {
            console.error('Disconnect error:', error);
            showNotification(`연동 해제 실패: ${error.message}`, 'error');
        }
    }

    // 모달 닫기
    function closeCalendarSyncModal() {
        const modal = document.getElementById('calendar-sync-modal');
        if (modal) {
            modal.remove();
        }

        // 전역 변수 초기화
        window.selectedCalendarId = null;
        window.selectedCalendarName = null;
    }

    // 캘린더 안내 관련 함수들
    function hideCalendarGuide() {
        const guide = document.getElementById('calendar-setup-guide');
        if (guide) {
            guide.style.animation = 'slideOutUp 0.3s ease-in forwards';
            setTimeout(() => {
                guide.classList.add('hidden');
            }, 300);

            // 로컬 스토리지에 숨김 상태 저장
            localStorage.setItem('calendar_guide_hidden', 'true');
        }
    }

    // 연결된 플랫폼이 있으면 자동으로 안내 숨기기
    function checkAndHideGuide() {
        const guide = document.getElementById('calendar-setup-guide');
        if (!guide) return;

        const isHidden = localStorage.getItem('calendar_guide_hidden') === 'true';

        // 전역 변수 hasCalendar 사용 (위에서 설정됨)
        if (typeof hasCalendar !== 'undefined' && (hasCalendar || isHidden)) {
            guide.style.display = 'none';
        } else if (!isHidden) {
            guide.style.display = 'block';
        }
    }

    // 캘린더 동기화 모달 열기 (기존 캘린더 선택 모달 사용)
    async function openCalendarSyncModal(platform) {
        console.log('📅 캘린더 변경 모달 열기, platform:', platform);

        // 기존 캘린더 선택 모달 사용
        await showCalendarSelectionModal(platform);
    }

    // 플랫폼 연결 표시 함수 (markPlatformConnected)
    function markPlatformConnected(platform) {
        const card = document.querySelector(`[data-platform="${platform}"]`);
        if (!card) return;

        // 기존 중복 버튼들 제거 (중복 방지)
        const existingGoogleDisconnectBtns = card.querySelectorAll('.google-disconnect-btn');
        existingGoogleDisconnectBtns.forEach(btn => btn.remove());
        console.log(`🧹 ${platform} 기존 연결해제 버튼 ${existingGoogleDisconnectBtns.length}개 제거됨`);

        // 플랫폼 상태를 연결됨으로 표시
        const statusElement = card.querySelector('.platform-status');
        if (statusElement) {
            statusElement.className = 'platform-status connected';
            statusElement.innerHTML = '<span class="status-dot"></span>연결됨';
        }

        // 일반 연결 버튼 숨기기 (중복 방지)
        const connectBtn = card.querySelector('.platform-connect-btn');
        const oneClickBtn = card.querySelector('.one-click-btn-small');

        if (connectBtn) {
            connectBtn.style.display = 'none';
        }

        // 원클릭 버튼을 연결해제 버튼으로 변경
        if (oneClickBtn) {
            const buttonText = oneClickBtn.querySelector('.btn-text');
            if (buttonText) {
                buttonText.textContent = '연결해제';
            }
            oneClickBtn.setAttribute('onclick', `oneClickDisconnect('${platform}')`);
            oneClickBtn.className = 'google-disconnect-btn';
        }

        // 🎯 캘린더 동기화 버튼 표시 (중요!)
        const syncBtn = card.querySelector('.platform-sync-btn');
        if (syncBtn) {
            syncBtn.style.display = 'inline-flex';
            syncBtn.style.visibility = 'visible';
            const syncText = syncBtn.querySelector('.sync-text');
            if (syncText) {
                syncText.textContent = '캘린더 변경';
            }
            console.log(`✅ ${platform} 캘린더 변경 버튼 표시됨 (display: ${syncBtn.style.display})`);
        } else {
            console.error(`❌ ${platform} 캘린더 변경 버튼을 찾을 수 없음`);
        }
    }

    // loadAllPlatformStatus 함수 정의 (updateAllPlatformStatus를 사용)
    async function loadAllPlatformStatus() {
        await updateAllPlatformStatus();
    }

    // loadSyncedCalendars 함수 정의 (checkCalendarsAndUpdatePlatforms를 사용)
    async function loadSyncedCalendars() {
        await checkCalendarsAndUpdatePlatforms();
    }


    // 페이지 로드 완료 후 연동 정보 불러오기
    document.addEventListener('DOMContentLoaded', async function () {

        // 먼저 플랫폼 연결 상태를 로드하고 UI를 초기화
        await loadAllPlatformStatus(); // Load platform connection states first
        // 그 다음에 캘린더 동기화 정보를 로드 (실제 연동된 경우에만 업데이트)
        await loadSyncedCalendars();
    });

</script>
{% endblock %}